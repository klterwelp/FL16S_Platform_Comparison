---
title: "Paired Amplicon Analysis"
author: "Kat Terwelp"
format: pdf
editor: visual
---

## Paired Amplicon Analysis

Amplicon single nucleotide variants are paired using BLAST (looking for identical matches).

```{r}
# load libraries
library(phyloseq) # for working with phyloseq objects
library(qiime2R) # import qza files
library(microViz) # useful phyloseq functions
library(ggpubr) # add statistics to graphs
library(skimr) # create summaries of dataframes (super useful!)
library(vegan) # beta diversity analyses
library(tidyverse) # useful 
library(ggbreak) # add axis breaks to plots 
```

```{r}
# import data 
cols <- c("query_asv", "query_len", "seq_asv", "seq_len", "alignment_len", "perc_id", "num_id", "evalue", "bitscore", "mismatch", "query_coverage", "gaps")

# import blast tsvs
blast_fl <- read_tsv("../intermediates/paired-blast-results/FL16S_paired-blast-results.tsv",
                     col_names = cols,
                     show_col_types = FALSE)
blast_v1v3 <- read_tsv("../intermediates/paired-blast-results/V1V3_paired-blast-results.tsv",
                       col_names = cols,
                       show_col_types = FALSE)

# import data and common utility functions
source("plot_utils.r", local = knitr::knit_global())
# this imports the tibbles created in 

# import original dada2 sequences
v1v3path <- "../data/16S_V1-V3/dada2_seq.fasta.qza"
flpath <- "../data/FL-16S/dada2_seq.fasta.qza"
seq_v1v3 <- read_qza(v1v3path)
seq_fl <- read_qza(flpath)
# remove paths 
rm(list = c("v1v3path", "flpath", "all_ps_path", "in_path"))

# extract input ASVs used for the paired blast 
name_seq_fl <- names(seq_fl$data)
## 4036 for FL-16S 
name_seq_v1v3 <- names(seq_v1v3$data)
## 2497 for V1-V3
# these include ASVs that were filtered out via decontam or taxonomic filtering

# functions
# function to filter blast table to just exact hits
f_filt_blast <- function(tbl) {
  tbl <- tbl %>% 
  filter(perc_id == 100) %>% # only 100% identity matches
  filter(alignment_len == seq_len | alignment_len == query_len) %>% # alignment length is equal to max overlap region
  group_by(query_asv) %>% 
  mutate(num_query_matches = length(unique(seq_asv))) %>% # number of ASVs that are exact matches for the query ASV
  mutate(hit_type = "match") %>% # these are exact matches
    ungroup()
  return(tbl)
}


```

```{r}
# combine match results
match_fl <- f_filt_blast(blast_fl) # these represent all FL16S matches
match_v1v3 <- f_filt_blast(blast_v1v3) # these represent all V1-V3 matches
# match_fl and match_v1v3 are reciprocals, where FL is the query in match_FL and the seq (match) in V1-V3
match <- bind_rows(match_fl, match_v1v3)
```

**Number of ASVs with Exact Matches**:

```{r}
fl_matches = match_fl$query_asv %>% n_distinct() # total FL ASVs with exact matches
paste0("There are ", fl_matches, " FL ASVs with exact matches")
v1v3_matches = match_v1v3$query_asv %>% n_distinct() # total V1-V3 ASVs with exact matches
paste0("There are ", v1v3_matches, " V1-V3 ASVs with exact matches")
match$query_asv %>% n_distinct() == fl_matches + v1v3_matches # should be equal
paste0("There are a total of ", n_distinct(match$query_asv), " matches")

# remove the extra variables
rm(list = c("fl_matches", "v1v3_matches"))
```

```{r}
# melt phyloseq object and prepare for combining with match results

# keep cols
ranks <- rank_names(all_ps)[c(1:7,9)]
meta_cols <- c("Sample", "Abundance", "shrt_sample_dna", "analysis", "total_reads", ranks)

# melt phyloseq object
melt <- all_ps %>% 
  ps_filter(analysis != "MGX") %>% # remove metagenomics data 
  ps_melt() %>% 
  select(any_of(meta_cols)) %>% # keep the keep cols
  rename_with(tolower) %>% # rename columns to lower case
  filter(abundance > 0) #remove nonexistant observations

# create a "query" and "sequence" version of the metadata to combine with all matches
melt_query <- melt %>% 
  rename_with(~paste0("query_", .x))
melt_seq <- melt %>% 
  rename_with(~paste0("seq_", .x))
```

```{r}
# Compare the ASVs in the melted phyloseq vs matched: 
ps_asvs = n_distinct(melt$asv) # number of total ASVs that are in the phyloseq 
non_match_asvs = setdiff(melt$asv, match$query_asv) %>% n_distinct() # ASVs in the melted phyloseq that are not in the match
filt_asvs = setdiff(match$query_asv, melt$asv) %>% n_distinct() # ASVs in the matched ASVs that are not in the phyloseq (filtered out)
int_asv_names = intersect(melt$asv, match$query_asv)
int_asvs = int_asv_names %>% n_distinct()
# the total match asvs minus the filtered ones should be equal to the ps asvs minus non matches
int_asvs == n_distinct(match$query_asv) - filt_asvs
int_asvs == ps_asvs - non_match_asvs
paste0("There are: ", non_match_asvs, " ASVs with no matches out of ", ps_asvs, " total")
paste0("There are: ", filt_asvs, " ASVs with matches that were filtered out")
paste0("There are: ", int_asvs, " ASVs present in matches and were not filtered out")

# remove these variables 
#rm(list = c("ps_asvs", "non_match_asvs", "filt_asvs"))
```

```{r}
# combine the metadata 
matched_meta <- full_join(match, melt_query, relationship = "many-to-many") 
# full join to capture the "query" asvs that are not matches 
# or were filtered out in ps (aka ASVs from dada2 that were filtered by decontam etc)
matched_meta <- left_join(matched_meta, melt_seq, relationship = "many-to-many")
# left join to only get metadata for sequences that matched queries
# there will be multiple matches because metadata is for each sample, so the same ASV will match multiple samples.
```

```{r}
# add information related to non-matches 
# these are the ASVs that do not have exact matches in the other platform
matched_meta <- matched_meta %>% 
  mutate(hit_type = case_when(hit_type == "match" ~ "match", 
                              .default = "non-match")) 
# all non-match should not have values in query_len because that's from blast metadata
matched_meta %>% filter(is.na(query_len)) %>% pull(hit_type) %>% unique() # non-match
matched_meta %>% filter(hit_type == "non-match") %>% pull(query_len) %>% unique() # NA

# we know from our setdiff that there are 2738 ASVs with no matches and 2231 matches
matched_meta %>% filter(hit_type == "non-match") %>% pull(query_asv) %>% n_distinct() == 2738
matched_meta %>% filter(hit_type == "match") %>% pull(query_asv) %>% n_distinct() == 2231
# what proportion of non-matches are V1-V3 vs FL
matched_meta %>% 
  filter(hit_type == "non-match") %>%
  select(query_asv, query_analysis) %>% 
  distinct() %>% 
  pull(query_analysis) %>% 
  table()
```

```{r}
# some ASVs were filtered out via taxonomy/decontam, these aren't in ps
# but they did have exact matches (potentially shared contamination)
# we know there are 245 ASVs that were filtered out but had matches 
# going to save these ASV names and add metadata cols to mark these
# some ASVs may always match with these filtered out ASVs, these will be marked too
# always_filt_pair are query asvs that lack any query-seq pairs that aren't filt out
# inherently this includes the 245 ASVs, but may also include other query ASVs (200 other)
melt_asvs <- melt$asv %>% unique() # all asvs that were in the ps object
matched_meta <- matched_meta %>% 
  mutate(seq_filt_out = case_when(is.na(seq_asv) ~ NA, 
                                  seq_asv %in% melt_asvs ~ FALSE, 
                                  .default = TRUE), 
         query_filt_out = case_when(is.na(query_asv) ~ NA,
                                    query_asv %in% melt_asvs ~ FALSE, 
                                    .default = TRUE)) %>% 
  group_by(query_asv, seq_asv) %>% 
  mutate(filt_out_pair = case_when(seq_filt_out | query_filt_out ~ TRUE,
                                   .default = FALSE)) %>% 
  ungroup() %>% 
  group_by(query_asv) %>% 
  mutate(always_filt_pair = case_when(hit_type != "match" ~ NA, 
                                      any(!filt_out_pair) ~ FALSE, 
                                      .default = TRUE))
         
                                   
# checking that only 245 unique seq and query asvs are marked as filtered out
matched_meta %>% 
  filter(seq_filt_out == TRUE) %>% 
  pull(seq_asv) %>% 
  n_distinct() == 245
matched_meta %>% 
  filter(query_filt_out == TRUE) %>% 
  pull(seq_asv) %>% 
  n_distinct() == 245

# there should also be 1986 ASVs with matches that weren't filtered out 
matched_meta %>% 
  filter(hit_type == "match") %>% 
  filter(query_filt_out == FALSE) %>% 
  pull(query_asv) %>% 
  n_distinct() == 1986

matched_meta %>% 
  filter(hit_type == "match") %>% 
  filter(seq_filt_out == FALSE) %>% 
  pull(seq_asv) %>% 
  n_distinct() == 1986

# what happens when I look at ASVs that aren't in a filt_out_pair 
always_filt_asvs = matched_meta %>% 
  filter(hit_type == "match") %>% 
  filter(always_filt_pair == TRUE) %>% 
  pull(query_asv) %>% unique()

# how many of these are not ASVs that were filtered out
filt_asvs = setdiff(match$query_asv, melt$asv)
setdiff(filt_asvs, always_filt_asvs) # should be 0 because all filt asvs should always be filt
new_filt_asvs = setdiff(always_filt_asvs, filt_asvs) 
# these asvs are always paired with a filtered ASV in the other dataset
# so if we add the 245 ASVs that were originally filtered + 200
# 445 ASVs are always filtered out either from being filtered themselves or only paired w/ filt
matched_meta %>% 
  filter(always_filt_pair == FALSE) %>% 
  pull(query_asv) %>% 
  n_distinct() == 1986 - n_distinct(new_filt_asvs) 
# leaving 1786 pairs which aren't filtered

# Are there ASVs that were filtered out in both datasets
matched_meta %>% 
  filter(query_filt_out == TRUE & seq_filt_out == TRUE) %>% 
  select(query_asv, query_len) %>% 
  mutate(likely_analysis = case_when(query_len > 1000 ~ "FL-16S",
                                     .default = "V1-V3")) %>% 
  distinct() %>% 
  group_by(likely_analysis) %>% 
  summarize(n = n()) 
# made "likely_analysis" because query_analysis isn't available w/o the metadata info
# total of 25 ASVs were filtered out in both, 18 from FL-16S and 7 from V1-V3
# Are there ASVs that were filtered in one dataset but not the other? 
matched_meta %>% 
  filter(filt_out_pair == TRUE) %>% 
  filter(query_filt_out == FALSE) %>% # gets only query filt FALSE and seq filt TRUE 
  select(query_asv, query_filt_out, query_analysis) %>% 
  distinct() %>% 
  group_by(query_filt_out, query_analysis) %>% 
  summarize(n = n())
# 192 FL-16S ASVs have V1-V3 matches that were filtered
# 28 V1-V3 ASVs have FL matches that were filtered out
# 25 ASVs that were filtered out in both
192+28+25 == 245 # should be equal to all filtered out ASVs
```

```{r}
# add in whether matched ASVs appear in the same sample
# and whether a match never appears in the same sample
# same_sample is when query sample and seq sample are the same
# while never_same_sample is when none of the samples that the query ASV is in match the seq
matched_meta <- matched_meta %>% 
  mutate(same_sample = case_when(is.na(query_sample) | is.na(seq_sample) ~ NA, # can't get info
                                 query_shrt_sample_dna == seq_shrt_sample_dna ~ TRUE,
                                 .default = FALSE)) %>% 
  group_by(query_asv, seq_asv) %>% # group by match pairs 
  mutate(never_same_sample = case_when(all(is.na(same_sample)) ~ NA, # filtered/non-match
                                       any(same_sample) ~ FALSE, # at least one match
                                       .default = TRUE
                                       )) %>% 
  ungroup() %>% 
  group_by(query_asv) %>% 
  mutate(query_nsamples = n_distinct(unique(query_shrt_sample_dna))) %>% 
  ungroup() %>% 
  group_by(seq_asv) %>% 
  mutate(seq_nsamples = n_distinct(unique(seq_shrt_sample_dna))) %>% 
  group_by(query_asv, seq_asv) %>% 
  mutate(query_uniq_samples = n_distinct(setdiff(c(unique(query_shrt_sample_dna)),
                                                 c(unique(seq_shrt_sample_dna)))),
         seq_uniq_samples = n_distinct(setdiff(c(unique(seq_shrt_sample_dna)), 
                                               c(unique(query_shrt_sample_dna)))),
         always_same_sample = case_when(filt_out_pair == TRUE ~ NA,
                                        hit_type != "match" ~ NA, 
                                        query_uniq_samples == 0 & seq_uniq_samples == 0 ~ TRUE,
                                        .default = FALSE)) %>% 
  ungroup()

# for never_same_sample, the number of query_uniq and seq_uniq should equal nsamples
matched_meta %>% 
  filter(never_same_sample == TRUE) %>% 
  select(query_asv, seq_asv, query_nsamples, seq_nsamples, query_uniq_samples, seq_uniq_samples) %>% 
  mutate(uniq_same_nsamples_query = query_uniq_samples == query_nsamples,
         uniq_same_nsamples_seq = seq_uniq_samples == seq_nsamples) %>% 
  group_by(uniq_same_nsamples_query, uniq_same_nsamples_seq) %>% 
  summarize(n = n())
# always TRUE! 

# how many total match pairs?
# how may are always filtered out or never in the same sample? 
matched_meta %>% 
  select(query_asv, query_analysis, seq_asv, hit_type, filt_out_pair, never_same_sample, always_same_sample) %>%
  distinct() %>% 
  group_by(hit_type, filt_out_pair, never_same_sample) %>% 
  summarize(n = n())

# how many matches are always in the same samples? 
matched_meta %>% 
  select(query_asv, seq_asv, query_analysis, always_same_sample) %>% 
  filter(always_same_sample == TRUE) %>% 
  distinct() %>% 
  summarize(n = n())
# 420 pairs are always in the same sample, so majority are not always in the same sample
```

A majority of match pairs (unique combos of query_asvs and seq_asvs) are not filtered out and do appear in the same sample at least once. However a minority of pairs (420) always appear in the same samples. Most of the time, they appear in some of the same samples.

```{r}
# add information on the number of unique species matches per query ASV
matched_meta <- matched_meta %>% 
  group_by(query_asv) %>% 
  mutate(num_species_matches = n_distinct(seq_species)) %>% 
  ungroup()
# also whether for a given pair, they are the same species who identified better
matched_meta <- matched_meta %>% 
  group_by(query_asv, seq_asv) %>% 
  mutate(same_species_pair = case_when(is.na(query_species) | is.na(seq_species) ~ NA, 
                                  query_species == seq_species ~ TRUE, 
                                  .default = FALSE)) %>% 
  mutate(better_species_pair = case_when(is.na(query_species) & is.na(seq_species) ~ "both_na",
                                         is.na(query_species) & !is.na(seq_species) ~ "seq", 
                                         !is.na(query_species) & is.na(seq_species) ~ "query",
                                         .default =  "both_species")) %>% 
  ungroup() 
```

### Characterizing non-matches

**How many ASVs had matches in the other dataset?**

```{r}
# how many ASVs were matches for V1-V3 and FL? 
matched_meta %>% 
  filter(query_filt_out == FALSE) %>% # remove filtered ASVs
  select(query_asv, query_analysis, hit_type) %>% 
  distinct() %>% # remove duplicates
  group_by(query_analysis, hit_type) %>% 
  summarize(n = n()) %>% 
  group_by(query_analysis) %>% 
  mutate(total = sum(n), 
         percent = n/total*100) %>% 
  select(-total)
```

A greater proportion (\~66%) of V1-V3 ASVs have no FL-16S counterpart. In comparison, only \~54% of FL-16S ASVs have no V1-V3 counterpart.

**How abundant are matches vs non-matches?**

```{r}
matched_meta %>% 
  filter(query_filt_out == FALSE) %>% # remove filtered ASVs
  select(query_asv, query_abundance, query_shrt_sample_dna, hit_type, query_analysis) %>% 
  distinct() %>% 
  ggplot(aes(x = query_shrt_sample_dna, y = query_abundance, fill = hit_type)) +
      geom_bar(stat = "identity", position = "stack", width = 1) +
      labs(title = "Relative Abundance of matched ASVs",
           x = "Sample",
           y = "Relative Abundance") +
      theme_bw() +
  facet_wrap(~query_analysis) +
  coord_flip() + 
  scale_y_continuous(expand = c(0, 0)) +
  labs(fill = "ASV Match") + 
  theme(axis.text.x = element_text(angle = 90, hjust = 0, vjust = 0),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(), 
        panel.spacing = unit(1.5, "lines"))


f_export_plot(plot = last_plot(), out_file = "../figures/non-match-abundance-barplot.png")
```

**For non-matches, what species are there?**

```{r}
amp_ps <- all_ps_count %>% 
  ps_filter(analysis != "MGX") 

taxa <- taxa_names(amp_ps)
match_taxa <- unique(match$query_asv)
non_match <- taxa[!(taxa %in% match_taxa)] # filter to only non-match
amp_ps_non_match <- prune_taxa(non_match, amp_ps) %>% 
  f_plot_prep_phyloseq(min_prev = 1, counts = TRUE)

comp_barplot(amp_ps_non_match, x = "shrt_sample_dna", n_taxa = 10, tax_level = "Species") +
  facet_wrap(~analysis) +
  coord_flip() +
  labs(x = "Sample") + 
  theme(axis.text.x = element_text(angle = 90, hjust = 0, vjust = 0),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank())

# the taxa that are non-matches are not particularly weird. They appear to be similar to the top taxa seen in these samples. 
f_export_plot(plot = last_plot(), out_file = "../figures/non-match-species-barplot.png")
```

```{r}
# also as tables of counts of ASVs (rather than just abundance)
query_taxonomy <- matched_meta %>% 
  filter(query_filt_out == FALSE) %>% # remove filtered ASVs
  select(query_asv, query_analysis, hit_type, query_kingdom, query_phylum, query_class, query_order, query_family, query_genus, query_species) %>% 
  distinct()  
  

# who in FL-16S was not matched in V1-V3? 
unmatched_fl <- query_taxonomy %>% 
  filter(hit_type == "non-match" & query_analysis == "FL-16S") %>% 
  group_by(query_analysis, query_genus, query_species) %>% 
  summarise(n = n()) %>% 
  arrange(desc(n))
head(unmatched_fl, n = 10)

# who in V1-V3 was not matched in FL-16S? 
unmatched_v1v3 <- query_taxonomy %>% 
  filter(hit_type == "non-match" & query_analysis == "V1-V3") %>% 
  group_by(query_analysis, query_genus, query_species) %>% 
  summarise(n = n()) %>% 
  arrange(desc(n)) 
head(unmatched_v1v3, n = 10)
 
```

### Match Differences

How many FL-16S ASVs match one V1-V3 sequence? What about vice-versa, how many V1-V3 ASVs match one FL-16S sequence?

```{r}
matched_meta %>% 
  filter(query_analysis == "V1-V3") %>% 
  select(query_asv, hit_type, num_query_matches) %>% 
  filter(hit_type == "match") %>% 
  distinct() %>% 
  ggplot(aes(x = num_query_matches)) +
  geom_histogram(binwidth = 1) +
  theme_minimal() + 
  labs(x = "Number of FL-16S ASVs Matches", y = "Count of V1-V3 ASVs") 

f_export_plot(plot = last_plot(), out_file = "../figures/num-fl16s-matches-per-v1v3-asv.png")
# also as a table
matched_meta %>% 
  filter(query_analysis == "V1-V3") %>% 
  select(query_asv, hit_type, num_query_matches) %>% 
  filter(hit_type == "match") %>% 
  pull(num_query_matches) %>% 
  unique() %>% 
  quantile()
# vice versa

matched_meta %>% 
  filter(query_analysis == "FL-16S") %>% 
  select(query_asv, hit_type, num_query_matches) %>% 
  filter(hit_type == "match") %>% 
  pull(num_query_matches) %>% 
  unique()
# FL-16S ASVs only match one 

# should I filter to remove species that were filtered out via decontam/taxonomic filter?
```

How does this translate to the number of unique species?

```{r}
matched_meta %>% 
  filter(query_analysis == "V1-V3") %>% 
  select(query_asv, hit_type, num_species_matches) %>% 
  filter(hit_type == "match") %>% 
  distinct() %>% 
  ggplot(aes(x = num_species_matches)) +
  geom_histogram(binwidth = 1) +
  theme_minimal() + 
  labs(x = "Number of Matched FL-16S Species", y = "Count of V1-V3 ASVs") 

f_export_plot(plot = last_plot(), out_file = "../figures/num-fl16s-species-per-v1v3-asv.png")

matched_meta %>% 
  filter(query_analysis == "V1-V3") %>% 
  select(query_asv, hit_type, num_species_matches) %>% 
  filter(hit_type == "match") %>% 
  pull(num_species_matches) %>% 
  unique() %>% 
  quantile()

# different ways to combine: 

# violin plot
matched_meta %>% 
  filter(query_analysis == "V1-V3") %>% 
  filter(hit_type == "match") %>% 
  filter(always_filt_pair == FALSE) %>% 
  select(query_asv, hit_type, num_species_matches, num_query_matches) %>% 
  distinct() %>% 
  ggplot(aes(x = as.factor(num_species_matches), y = num_query_matches)) +
  geom_violin() + 
  geom_jitter()

# colored bars with break
matched_meta %>% 
  filter(query_analysis == "V1-V3") %>% 
  select(query_asv, hit_type, num_query_matches, num_species_matches) %>% 
  filter(hit_type == "match") %>% 
  distinct() %>% 
  ggplot(aes(x = num_query_matches)) +
  geom_histogram(binwidth = 1, aes(fill = as.factor(num_species_matches))) +
  theme_minimal() +
  scale_y_break(c(70, 230), scales = "free", expand = FALSE) +
  labs(x = "Number of FL-16S ASV Matches", y = "Count of V1-V3 ASVs", 
       fill = "Number of FL-16S Species") 

# colored bars without break, facet by 1 or not 
matched_meta %>% 
  filter(query_analysis == "V1-V3") %>% 
  select(query_asv, hit_type, num_query_matches, num_species_matches) %>% 
  mutate(num_species_g1 = ifelse(num_species_matches > 1, TRUE, FALSE))
  filter(hit_type == "match") %>% 
  distinct() %>% 
  ggplot(aes(x = num_query_matches)) +
  geom_histogram(binwidth = 1, aes(fill = as.factor(num_species_matches))) +
  theme_minimal() +
  scale_y_break(c(70, 230), scales = "free", expand = FALSE) +
  labs(x = "Number of FL-16S ASV Matches", y = "Count of V1-V3 ASVs", 
       fill = "Number of FL-16S Species") 

# no point to do FL-16S because it'll be 1 species per 1 ASV that matches
```

How well do these matched ASV abundance correlates with one another?

```{r}
# filter the table to just exact matches
# also calculate relative abundance
same_sample_matches <- matched_meta %>% 
  filter(hit_type == "match") %>% 
  filter(same_sample == TRUE) 

# correct for the fact that multiple FL-16S ASVs match a single V1-V3 ASV
# this means grouping by query and seq ASVs 
# then calculating the sum of relative abundance for the grouped matches
same_sample_matches <- same_sample_matches %>% 
  group_by(seq_shrt_sample_dna, query_asv) %>%
  mutate(seq_abundance_corrected = sum(seq_abundance)) %>%
  group_by(seq_shrt_sample_dna, seq_asv) %>%
  mutate(query_abundance_corrected = sum(query_abundance)) %>%
  ungroup()

```

```{r}
# plot of how well correlated the matches are in terms of abundance
# only looking at ASV matches that appear in the exact same sample
# removes non-matches and matches in different samples 
# and removes matches where one ASV is present and the other is not
plot_data <- same_sample_matches %>%
  select(query_asv, query_shrt_sample_dna, seq_abundance, seq_abundance_corrected, query_abundance_corrected, query_analysis, same_species_pair) %>% 
  distinct()


plot_data %>% 
  filter(query_analysis == "FL-16S") %>% # no reason to have a reflected plot
  ggplot(aes(x=query_abundance_corrected, y=seq_abundance_corrected)) +
  geom_point(aes(color = same_species_pair)) +
  scale_alpha(guide = "none") +
  geom_abline() +
  theme_minimal() +
  labs(x = "FL-16S Relative Abundance", 
       y = "V1-V3 Relative Abundance", 
       color = "Same Species") +
  scale_x_sqrt() +
  scale_y_sqrt() 

f_export_plot(plot = last_plot(), out_file = "../figures/match-abundance-correlation.png")

# how does this compare to an uncorrected graph? 
uncor_plot_data <- same_sample_matches %>%
  select(query_asv, query_shrt_sample_dna, seq_abundance, query_abundance, query_analysis, same_species_pair) %>% 
  distinct() 

uncor_plot_data %>% 
  filter(query_analysis == "FL-16S") %>% # no reason to have a reflected plot
  ggplot(aes(x=seq_abundance, y=query_abundance)) +
  geom_point(aes(color = same_species_pair)) +
  scale_alpha(guide = "none") +
  geom_abline() +
  theme_minimal() +
  labs(x = "FL-16S Relative Abundance", 
       y = "V1-V3 Relative Abundance", 
       color = "Same Species") +
  scale_x_sqrt() +
  scale_y_sqrt() 
```

```{r}
# statistics for this correlation? 
cor.test(plot_data$seq_abundance_corrected, plot_data$query_abundance_corrected, method = "spearman")
lm(plot_data$seq_abundance_corrected ~ plot_data$query_abundance_corrected)
# versus uncorrected correlation
cor.test(uncor_plot_data$seq_abundance, uncor_plot_data$query_abundance, method = "spearman")
```

```{r}
# what about as a linear model
lm(seq_abundance_corrected ~ query_abundance_corrected, plot_data) %>% summary()
# positive relationship but not significant
```

What proportion of species calls are the same vs different vs na?

```{r}
species_calls <- matched_meta %>% 
  filter(hit_type == "match") %>% 
  filter(query_filt_out == FALSE & seq_filt_out == FALSE) %>% # remove filtered ASVs
  select(query_asv, seq_asv, query_analysis, same_species_pair) %>% 
  distinct()

# proportion of same species calls 
species_calls %>% 
  filter(!is.na(same_species_pair)) %>% 
  select(query_asv, seq_asv, query_analysis, same_species_pair) %>% 
  distinct() %>% 
ggplot(aes(x = query_analysis, fill = same_species_pair)) +
  geom_bar()
```

A greater proportion of ASV matches are considered the same species across both analyses. Something feels off about this defintion. Instead, I should group by the query_asv variable and then check for all matches whether they are identical, so that I'm not double-counting.

```{r}
# try again with new definition
species_calls <- matched_meta %>% 
  filter(hit_type == "match") %>% 
  filter(query_filt_out == FALSE) %>% # remove filtered ASVs
  select(query_asv, seq_asv, query_analysis, query_species, seq_species, same_species_pair) %>% 
  distinct() %>% 
  group_by(query_asv) %>% 
  mutate(same_species_pair_by_query = case_when(
    any(c(is.na(query_species), is.na(seq_species))) ~ NA, 
    all(query_species == seq_species) ~ TRUE,
    !all(query_species == seq_species) ~ FALSE))

# proportion of same species calls 
species_calls %>% 
  select(query_analysis, same_species_pair_by_query) %>% 
  distinct() %>% 
ggplot(aes(x = query_analysis, fill = same_species_pair_by_query)) +
  geom_bar()

# now only few query ASVs have false same species, instead there's a greater proportion of NA calls. This motivates further investigation and I will continue adjusting my definitions. 
```

The bulk of these results are NA for either the query ASV or the seq ASV. Let's investigate whether it is the sequence ASV or the query ASV that is NA.

```{r}
species_calls <- species_calls %>% 
  group_by(query_asv) %>% 
  mutate(prop_na_query = (sum(is.na(query_species))/n()),
         prop_na_seq = (sum(is.na(seq_species))/n())) %>%
  mutate(better_species = case_when(prop_na_query > prop_na_seq ~ FALSE, 
                                    prop_na_query < prop_na_seq ~ TRUE, 
                                    .default = NA))
  
# prop_na: when grouping by query ASV, the proportion of NA for the query and sequence matches to that query 
# better species when the proportion of NA is lower for the query than its sequence matches
# NA is when both fail to get to species level 

species_calls %>% 
  select(query_asv, query_analysis, better_species) %>% 
  distinct() %>% 
ggplot(aes(x = query_analysis, fill = better_species)) +
  geom_bar()


# only when one is not NA: 
species_calls %>% 
  filter(!is.na(better_species)) %>% 
  select(query_asv, query_analysis, better_species) %>% 
  distinct() %>% 
  group_by(query_analysis, better_species) %>% 
  summarize(n = n())
```

This is very interesting, for the ASVs which were not NA for both platforms, proportionally half of V1-V3 and FL16S had either better species identification or not. The biggest proportion is where both fail to classify the ASV to species level.

```{r}
# what about the proporotion of ASVs classified at species level? 
melt %>% 
  select(asv, analysis, species) %>% 
  distinct() %>% 
  group_by(analysis) %>% 
  summarise(n = n(), classified = sum(!is.na(species)), proportion = classified/n) 
```
